### function to train halfspaces on data (Chen et al. 2015)

### input: data (train data): matrix row wise
###        n_halfspace (number of drawn halfspaces): count
###        subsample (fraction used for the halfspaces): numeric > 0 and <= 1
###        scope (lambda parameter of the Algorithm): numeric > 0
###        seed (random seed): numeric

### output: halfspaces: of class "halfspace" list of the directions used for
###                     the halfspace, the split points, the number of data
###                     points left to the halfspace and the number of data
###                     points right to the halfspace
train_depth <- function(data, n_halfspace, subsample = 1, scope = 1, seed) {
  ### input checks
  data <- as.matrix(data)
  checkmate::assert_matrix(data, any.missing = FALSE, all.missing = FALSE)
  checkmate::assert_count(n_halfspace, positive = TRUE)
  checkmate::assert_number(subsample, lower = 0.001, upper = 1, finite = TRUE)
  checkmate::assert_number(scope, lower = 0.001, finite = TRUE)
  checkmate::assert_number(seed, finite = TRUE)

  ### dimension of the data, number of data points and samplesize
  dimension <- NCOL(data)
  n_obs <- NROW(data)
  all_obs <- seq_len(n_obs)
  samplesize <- ceiling(subsample * n_obs)

  ### set the seed
  set.seed(seed)

  ### generate the halfspaces
  directions <- matrix(0, nrow = n_halfspace, ncol = dimension)
  split_points <- numeric(n_halfspace)
  n_left <- numeric(n_halfspace)
  for (i in seq_len(n_halfspace)) {
    ### sample a direction
    directions[i, ] <- sample_direction(dimension)

    ### sample the data
    data_sample <- sample_data(data, subsample = subsample,
                               samplesize = samplesize, all_obs = all_obs)

    ### calculate the projections
    projections <- data_sample %*% directions[i, ]

    ### get the split point
    split_points[i] <- get_split_point(projections, scope = scope)

    ### determine the number of data points left and right to the split point
    n_left[i] <- sum(projections < split_points[i])
  }

  halfspaces <- list(directions = directions, split_points = split_points,
                     n_leftright = cbind(n_left, n_right = samplesize - n_left))

  ### set samplesize attribute because we need this information later for the
  ### calculation of the metric
  attr(halfspaces, which = "samplesize") <- samplesize

  ### assign the halfspaces the halfspace class so we can later input check
  ### this in evaluate_depth
  class(halfspaces) <- "halfspace"

  halfspaces
}

### function to calculate the halfspace mass or depth of some test data with
### respect to trained halfspaces

### input: data (train data): matrix row wise or a vector
###        halfspaces (of class halfspace) generated by train_depth
###        metric: "mass" vs. "depth"

### output: vector of length NROW(data) with the halfspace metric of each point
evaluate_depth <- function(data, halfspaces, metric = c("mass", "depth")) {
  ### input checks
  data <- if (is.vector(data)) {
    t(data)
  } else {
    as.matrix(data)
  }
  checkmate::assert_matrix(data, any.missing = FALSE, all.missing = FALSE)
  checkmate::assert_class(halfspaces, classes = "halfspace")
  metric <- match.arg(metric, choices = c("mass", "depth"))

  ### calculate the halfspace metric for each data point
  calculate_metric(data, halfspaces = halfspaces, metric = metric)
}


### function to sample a direction on the R^n (n = dimension) unit sphere
sample_direction <- function(dimension) {
  direction <- rnorm(dimension, mean = 0, sd = 1)
  direction / as.vector(sqrt(crossprod(direction)))
}

### function to sample data row wise
sample_data <- function(data, subsample, samplesize, all_obs) {
  ### decide whether we actually subsample or use the whole data
  if (subsample < 1) {
    data[sample(all_obs, size = samplesize, replace = FALSE), , drop = FALSE]
  } else {
    data
  }
}

### function to get the split point as defined in Algorithm 1
get_split_point <- function(projections, scope) {
    max_projection <- max(projections)
    min_projection <- min(projections)
    mid_projection <- (max_projection + min_projection) / 2
    split_length <- (scope / 2) * (max_projection - min_projection)

    runif(1, mid_projection - split_length, mid_projection + split_length)
}

### function to calculate the halfspace metric (mass or depth)
calculate_metric <- function(data, halfspaces, metric) {
  samplesize <- attr(halfspaces, which = "samplesize")

  ### halfspaces is a list containing:
  ###   [[1]] "directions" the directions
  ###   [[2]] "split_points" the split points
  ###   [[3]] "n_leftright" the absolute numbers of data points that are left to
  ###         the halfspace after projection onto the direction (first column)
  ###         and the absolute numbers ... that are right ... (second column)
  ### for each halfspace calculate the scalar projection of the data onto the
  ### direction, if this is smaller than the split point, select n_left,
  ### otherwise n_right

  ### compare the projections of the data onto the directions with the split
  ### points
  comparisons <- (halfspaces[[1L]] %*% t(data)) < halfspaces[[2L]]

  ### select n_left if TRUE, n_right if FALSE
  hm <- apply(comparisons, MARGIN = 2L, FUN = function(j) {
    c(halfspaces[[3L]][j, 1L],
      halfspaces[[3L]][!j, 2L])
  })

  ### return the halfspace mass or depth
  switch(metric,
         "mass" = colMeans(hm / samplesize),
         "depth" = apply(hm, MARGIN = 2L, FUN = min))
}

